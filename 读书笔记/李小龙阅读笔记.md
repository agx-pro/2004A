# **1.18** 笔记

- 完整的JavaScript包含：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。
- **核心（ECMAScript）**

ECMAScript，即ECMA-262定义的语言，并不局限于Web浏览器。Web浏览器只是ECMAScript实现可能存在的一种宿主环境（host
environment）。
ECMA-262描述的语言：语法、类型、语句、关键字、保留字、操作符、全局对象。

**文档对象模型（DOM）**

文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽

DOMLevel2 新增了以下模块，以支持新的接口：
- DOM视图：描述追踪文档不同视图（如应用CSS样式前后的文档）的接口。
- DOM事件：描述事件及事件处理的接口。
- DOM样式：描述处理元素CSS样式的接口。
- DOM遍历和范围：描述遍历和操作DOM树的接口。

#### 二script元素


async ：可选。表示应该立即开始下载脚本，但不能阻止其他 页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效


charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在它的值。


crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。 


crossorigin="anonymous" 配置文件请求不必设置凭据标志。 crossorigin="usecredentials" 设置凭据标志，意味着出站请求会包含凭据。


defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效 在IE7及更早的版本中，对行内脚本也可以指定这个属性。


integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整（SRISubresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN,Content Delivery Network）不会提供恶意内容。


language ：废弃。最初用于表示代码块中的脚本语言（如 "JavaScript" 、 "JavaScript 1.2" 或"VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。


src ：可选。表示包含要执行的代码的外部文件。


type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。按照例，这个值始终都是 "text/javascript" ，尽管 "text/javascript" 和 "text/ecmascript" 都已经废弃了。JavaScript文件的MIME类型通常是 "application/x- javascript" ，不过给type属性这个值有可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有 "application/javascript" 和"application/ecmascript" 。如果这个值是 module ，则代码会被当成ES6模块，而且只有这时候代码中才能出现 import 和 export 关键字。使用 <script> 的方式有两种：通过它直接在网页中嵌入JavaScript代码，以及通过它在网页中包含外部JavaScript文件。

#### 3.什么是javascript？


	1、javascript是一种基于对象和事件驱动的客户端脚本语言。
	2、javascript最初的设计师为了检验HTML表单输入的正确性
	3、javascript起源于Netscape公司的livescript语言。
### 标签占位符


过去，所有 <script> 元素都被放在页面的 <head> 标签内，这种做法的主要目的是把外部的CSS和JavaScript文件都集中放到一起，这样一来，页面会在处理JavaScript代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了


### 推迟执行脚本

HTML 4.01为 <script> 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行在 <script> 元素上设defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟。对 defer 属性的支持是从IE4、Firefox3.5、Safari 5和Chrome 7开始的。其他所有浏览器则会忽略这个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好

### 文档模式三种


混杂模式(quirks mode)和标准模式(standards mode)准标准模式(almoststandards mode)


混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关


准标准模式通过过渡性文档类型（ Transitional ）和框架集文档类型（ Frameset ）来触发


准标准模式与标准模式非常接近，很少需要区分。人们在说到“标准模式”时，可能指其中任何一个。而对文档模式的检测（本书后面会讨论）也不会区分它们。本书后面所说的标准模式，指的就是除混杂模式以外的模式

##### 语法结构

标识符
    定义：标识符是指变量、函数、属性的名字，或者函数的参数 通俗的讲：标识符就是一个名字
 命名规则：
        标识符首字符可以是以下划线（_）、美元符($)或者字母开始，不能是数字。
        标识符中其它字符可以是下划线（_）、美元符($)、字母或数字组成的。
        普通标识符（用作变量名、函数名和循环语句中用于跳转的标记）不能是保留字符

# 1.19笔记 


##### 4.1 原始值与引用值


ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据，引用值  则是由多个值构成的对象。


保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。


在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。


##### 4.1.1 动态属性


原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。


这里，首先创建了一个对象，并把它保存在变量person 中。然后，给这个对象添加了一个名为name 的属性，并给这个属性赋值了一个字符串"Nicholas" 。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。


##### 4.1.2 复制值


除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。


##### 4.1.3 传递参数


ECMAScript中所有函数的参数都是按值传递的。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。


##### 4.1.4 确定类型


typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined 的最好方式。如果值是对象或null ，那么typeof 返回"object"


#### 4.2 执行上下文与作用域


执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。主要有全局上下文和函数上下文两种。


##### 4.2.1 作用域链增强


try / catch 语句的catch 块
with 语句
这两种情况下，都会在作用域链前端添加一个变量对象。对with 语句来说，会向作用域链前端添加指定的对象；对catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。


##### 4.2.2 变量声明


1. 使用var 的函数作用域声明


在使用var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。


2. 使用let 的块级作用域声明


ES6新增的let 关键字跟var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{} 界定。换句话说， if 块、while 块、function块，甚至连单独的块也是let 声明变量的作用域。


3. 使用const 的常量声明


ES6同时还增加了const 关键字。使用const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。


4. 标识符查找


当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。

#### 4.3 垃圾回收

JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。

 \##### 4.3.1 标记清理

   JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）

   当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑

   上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运

   行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下 文的标记。

   4.3.2 引用计数

   另一种没那么常用的垃圾回收策略是引用计数（referencecounting）。其思路是对每个值都记录它被引用的次数。声明变量并它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办 法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为0的值的内存。 4.3.4 内存管理 在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。 不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分  配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。 

4.4 小结

   JavaScript变量可以保存两种类型的值：原始值和引用值。原始值

   可能是以下6种原始数据类型之一： Undefined 、Null 、 Boolean 、Number

   、String 和Symbol 。原始值和引用值有 以下特点。

   原始值大小固定，因此保存在栈内存上。

   从一个变量到另一个变量复制原始值会创建该值的第二个副本。

   引用值是对象，存储在堆内存上。

   包含引用值的变量实际上只包含指向相应对象的一个指针，而不 是对象本身。

   从一个变量到另一个变量复制引用值只会复制指针，因此结果是

   两个变量都指向同一个对象。 typeof 操作符可以确定值的原始类型，而instanceof

   操作 符用于确保值的引用类型。

   任何变量（不管包含的是原始值还是引用值）都存在于某个执行

   上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生

   命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如 下。

   执行上下文分全局上下文、函数上下文和块级上下文。

   代码执行流每进入一个新上下文，都会创建一个作用域链，用于 搜索变量和函数。

   函数或块的局部上下文不仅可以访问自己作用域内的变量，而且

   也可以访问任何包含上下文乃至全局上下文中的变量。

   全局上下文只能访问全局上下文中的变量和函数，不能直接访问

   局部上下文中的任何数据。 变量的执行上下文用于确定什么时候释放内存。

   JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分

   配和回收。JavaScript的垃圾回收程序可以总结如下。

   离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被 删除。

   主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标

   记，再回来回收它们的内存。

   引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。

 