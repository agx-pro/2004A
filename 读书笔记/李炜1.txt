变量、作用域与内存
JavaScript变量是松散类型的，而且变量不过就是特定
时间点一个特定值的名称而已。由于没有规则定义变量必须包含什么
数据类型，变量的值和数据类型在脚本生命期内可以改变。这样的变
量很有意思，很强大，当然也有不少问题
ECMAScript变量可以包含两种不同类型的数据：原始值和引用
值。原始值（primitive value）就是最简单的数据，引用值（reference
value）则是由多个值构成的对象
原始值
可能是以下6种原始数据类型之一
 Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol
原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。
从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。

执行上下文与作用域
执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重
要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们
的行为。每个上下文都有一个关联的变量对象（variable object），而
这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法
通过代码访问变量对象，但后台处理数据会用到它。
全局上下文是最外层的上下文。根据ECMAScript实现的宿主环
境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就
是我们常说的 window 对象
每个函数调用都有自己的上下文。当代码执行流进入函数时，函
数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会
弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript
程序的执行流就是通过这个上下文栈进行控制的。
上下文中的代码在执行的时候，会创建变量对象的一个作用域链
（scope chain）。这个作用域链决定了各级上下文中的代码在访问变
量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用
域链的最前端。如果上下文是函数，则其活动对象（activation
object）用作变量对象。活动对象最初只有一个定义变量：
arguments 。（全局上下文中没有这个变量。）作用域链中的下一
个变量对象来自包含上下文，再下一个对象来自再下一个包含上下
文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域
链的最后一个变量对象

垃圾回收 
JavaScript 中的内存管理是自动执行的，而且是不可见的。
我们创建基本类型、对象、函数……所有这些都需要内存
标记清理
JavaScript最常用的垃圾回收策略是标记清理（mark-and￾sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个
变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑
上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运
行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下
文的标记
垃圾回收程序运行的时候，会标记内存中存储的所有变量它会将所有在上下文中的变量，以
及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标
记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到
它们了。随后垃圾回收程序做一次内存清理
引用计数
另一种没那么常用的垃圾回收策略是引用计数（reference
counting）。其思路是对每个值都记录它被引用的次数。声明变量并给
它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一
个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他
值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办
法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序
下次运行的时候就会释放引用数为0的值的内存。
性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可
能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有
限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。
开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代
码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工
作
内存管理
在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。
不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分
配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏
览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运
行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存
限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执
行的语句数量。
内存泄漏
写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。
在内存有限的设备上，或者在函数会被调用很多次的情况下，内
存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合
理的引用导致的。
意外声明全局变量是最常见但也最容易修复的内存泄漏问题。下
面的代码没有使用任何关键字声明变量：

 