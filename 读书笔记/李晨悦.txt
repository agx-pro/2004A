1、完整的JavaScript实现包含哪几个部分？
核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）
1、文档对象模型（DOM）：一个应用编程接口（API），用在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据。
2、浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。

2、script 元素
1、async：表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。
2、charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
3、crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。
4、src ：可选。表示包含要执行的代码的外部文件。
5、type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。

3、推迟的脚本
script 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。在 script>元素上设置defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟。

4、异步执行脚本
async 属性从改变脚本处理方式上看defer 类似，两者只适用于外部脚本，会告诉浏览器立即开始下载；不过，与 defer不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行。

5、动态加载脚本
通过向DOM中动态添加 script元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到DOM即可。

6、行内代码与外部文件
推荐使用外部文件，理由：
1、可维护性，用一个目录保存所有JavaScript文件更容易维护。
2、缓存，浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
3、适应未来。通过把JavaScript放到外部文件中，就不必考虑用XHTML或前面提到的注释黑科技。包含外部JavaScript文件的语法在HTML和XHTML中是一样的。

7、文档模式
概念：即可以使用 doctype 切换文档模式。
混杂模式、标准模式、准标准模式：
主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）；
混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关；
准标准模式通过过渡性文档类型和框架集文档类型来触发。

8、区分大小写
typeof 不能作为函数名，因为它是一个关键字；但 Typeof 是一个完全有效的函数名。

9、标识符
标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
第一个字符必须是一个字母、下划线（ _ ）或$ ；剩下的其他字符可以是字母、下划线、美元符号或数字。

10.严格模式
1、ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：“use strict”;
2、虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持JavaScrip引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。
3、也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可。

11、变量
var 声明作用域：，使用 var 操作符定义的变量会成为包含它的函数的局部变量。

12、var 声明提升
使用这个关键字声明的变量会自动提升到函数作用域顶部；也就是把所有变量声明都拉到函数作用域的顶部；此外，反复多次使用 var 声明同一个变量也没有问题。

13、let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是， let 声明的范围是块作用域，而var 声明的范围是函数作用域。

14、 暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。

15、 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声明的变量则会）。
为了避免 SyntaxError ，必须确保页面不会重复声明同一个变量。

16、条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。
使用 try / catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。

17、for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部。
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部。

18、const和let的区别
1、const 声明 const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。
2、const 声明的限制只适用于它指向的变量的引用。如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。

19、数据类型
ECMAScript有6种简单数据类型（也称为原始类型）：
Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集合。因为ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。

20、typeof 操作符
“undefined” 表示值未定义；
“boolean” 表示值为布尔值；
“string” 表示值为字符串；
“number” 表示值为数值；
“object” 表示值为对象（而不是函数）或 null ； “function” 表示值为函数；
“symbol” 表示值为符号。

21、Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。

22、Null 类型
1、Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 “object” 的原因。
2、用等于操作符（ == ）比较 null 和 undefined 始终返回true 。

23、Boolean 类型
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，因此 true 不等于1， false 不等于0。

24、 NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not aNumber），用于表示本来要返回数值的操作失败了（而不是抛出错误）。

25、数值转换
有3个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number() 函数基于如下规则执行转换。布尔值， true 转换为1， false 转换为0。
数值，直接返回。null ，返回0。 undefined ，返回 NaN 。

26、String 类型
String （字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（’）或反引号（`）标示。

27、Symbol.isConcatSpreadable
根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是 true ，则意味着对象应该用Array.prototype.concat() 打平其数组元素”。ES6中的Array.prototype.concat() 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖Symbol.isConcatSpreadable 的值可以修改这个行为。数组对象默认情况下会被打平到已有的数组， false 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾， true 或真值会导致这个类数组对象被打平到数
组实例。其他不是类数组对象的对象在Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。

28、Symbol.iterator
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器API的函数。

29、Symbol.split
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由String.prototype.split() 方法使用”。 String.prototype.split() 方法会使用以
Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数。

30、 Symbol.toStringTag
根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Object.prototype.toString() 使用”。通过 toString() 方法获取对象标识时，会检索由Symbol.toStringTag 指定的实例标识符，默认为 “Object” 。内置类型已经指定了这个值，但自定义类实例还需要明确定义。