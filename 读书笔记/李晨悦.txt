1.18
1、完整的JavaScript实现包含哪几个部分？
核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）
1、文档对象模型（DOM）：一个应用编程接口（API），用在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据。
2、浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。

2、script 元素
1、async：表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。
2、charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
3、crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。
4、src ：可选。表示包含要执行的代码的外部文件。
5、type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。

3、推迟的脚本
script 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。在 script>元素上设置defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟。

4、异步执行脚本
async 属性从改变脚本处理方式上看defer 类似，两者只适用于外部脚本，会告诉浏览器立即开始下载；不过，与 defer不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行。

5、动态加载脚本
通过向DOM中动态添加 script元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到DOM即可。

6、行内代码与外部文件
推荐使用外部文件，理由：
1、可维护性，用一个目录保存所有JavaScript文件更容易维护。
2、缓存，浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
3、适应未来。通过把JavaScript放到外部文件中，就不必考虑用XHTML或前面提到的注释黑科技。包含外部JavaScript文件的语法在HTML和XHTML中是一样的。

7、文档模式
概念：即可以使用 doctype 切换文档模式。
混杂模式、标准模式、准标准模式：
主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）；
混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关；
准标准模式通过过渡性文档类型和框架集文档类型来触发。

8、区分大小写
typeof 不能作为函数名，因为它是一个关键字；但 Typeof 是一个完全有效的函数名。

9、标识符
标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
第一个字符必须是一个字母、下划线（ _ ）或$ ；剩下的其他字符可以是字母、下划线、美元符号或数字。

10.严格模式
1、ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：“use strict”;
2、虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持JavaScrip引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。
3、也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可。

11、变量
var 声明作用域：，使用 var 操作符定义的变量会成为包含它的函数的局部变量。

12、var 声明提升
使用这个关键字声明的变量会自动提升到函数作用域顶部；也就是把所有变量声明都拉到函数作用域的顶部；此外，反复多次使用 var 声明同一个变量也没有问题。

13、let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是， let 声明的范围是块作用域，而var 声明的范围是函数作用域。

14、 暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。

15、 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声明的变量则会）。
为了避免 SyntaxError ，必须确保页面不会重复声明同一个变量。

16、条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。
使用 try / catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。

17、for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部。
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部。

18、const和let的区别
1、const 声明 const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。
2、const 声明的限制只适用于它指向的变量的引用。如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。

19、数据类型
ECMAScript有6种简单数据类型（也称为原始类型）：
Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集合。因为ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。

20、typeof 操作符
“undefined” 表示值未定义；
“boolean” 表示值为布尔值；
“string” 表示值为字符串；
“number” 表示值为数值；
“object” 表示值为对象（而不是函数）或 null ； “function” 表示值为函数；
“symbol” 表示值为符号。

21、Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。

22、Null 类型
1、Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 “object” 的原因。
2、用等于操作符（ == ）比较 null 和 undefined 始终返回true 。

23、Boolean 类型
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，因此 true 不等于1， false 不等于0。

24、 NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not aNumber），用于表示本来要返回数值的操作失败了（而不是抛出错误）。

25、数值转换
有3个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number() 函数基于如下规则执行转换。布尔值， true 转换为1， false 转换为0。
数值，直接返回。null ，返回0。 undefined ，返回 NaN 。

26、String 类型
String （字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（’）或反引号（`）标示。

27、Symbol.isConcatSpreadable
根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是 true ，则意味着对象应该用Array.prototype.concat() 打平其数组元素”。ES6中的Array.prototype.concat() 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖Symbol.isConcatSpreadable 的值可以修改这个行为。数组对象默认情况下会被打平到已有的数组， false 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾， true 或真值会导致这个类数组对象被打平到数
组实例。其他不是类数组对象的对象在Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。

28、Symbol.iterator
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器API的函数。

29、Symbol.split
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由String.prototype.split() 方法使用”。 String.prototype.split() 方法会使用以
Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数。

30、 Symbol.toStringTag
根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Object.prototype.toString() 使用”。通过 toString() 方法获取对象标识时，会检索由Symbol.toStringTag 指定的实例标识符，默认为 “Object” 。内置类型已经指定了这个值，但自定义类实例还需要明确定义。
1.19
1、传递参数
ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。

2、确定类型
1、typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象，所以ECMAScript提供了 instanceof 操作符。
2、如果变量是给定引用类型的实例，则 instanceof 操作符返回 true 。
3、按照定义，所有引用值都是 Object 的实例，因此通过instanceof 操作符检测任何引用值和 Object 构造函数都会返回 true 。类似地，如果用 instanceof 检测原始值，则始终会返回 false ，因为原始值不是对象。

3、执行上下文
1、全局上下文是最外层的上下文，在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过var 定义的全局变量和函数都会成为 window 对象的属性和方法。
2、使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。
3、上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。

总分类：
全局上下文、 changeColor() 的局部上下文和 swapColors() 的局部上下文。
全局上下文中有一个变量 color 和一个函数 chageColor() 。
changeColor() 的局部上下文中有一个变量 anotherColor 和一个函数swapColors() ，但在这里可以访问全局上下文中的变量color 。
swapColors() 的局部上下文中有一个变量tempColor ，只能在这个上下文中访问到。
全局上下文和changeColor() 的局部上下文都无法访问到 tempColor 。而在swapColors() 中则可以访问另外两个上下文中的变量，因为它们都是父上下文。

4、作用域链
1、虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。
2、try / catch 语句的 catch 块 with 语句：都会在作用域链前端添加一个变量对象。
对with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

5、变量声明
1、使用 var 的函数作用域声明：
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。
2. 使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说， if 块、 while 块、 function块，甚至连单独的块也是 let 声明变量的作用域。
3. 使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。

6、垃圾回收
1、标记清理
JavaScript最常用的垃圾回收策略是标记清理。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
2 、引用计数
另一种没那么常用的垃圾回收策略是引用计数，其思路是对每个值都记录它被引用的次数。
3 、性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。

7、内存管理
1、通过 const 和 let 声明提升性能；
2、 隐藏类和删除操作；
3. 内存泄漏；
4. 静态分配与对象池

8、小结
1、JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。
2、原始值和引用值有以下特点:
原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。