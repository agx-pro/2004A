### JavaScript实现

```
核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM）
```

#### 严格模式

```
ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是
一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写
法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个
脚本启用严格模式，在脚本开头加上这一行：
"use strict";
虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个
预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。
选择这种语法形式的目的是不破坏ECMAScript 3语法。
也可以单独指定一个函数在严格模式下执行，只要把这个预处理
指令放到函数体开头即可：
function doSomething() {
"use strict";
// 函数体
}
严格模式会影响JavaScript执行的很多方面，因此本书在用到它时
会明确指出来。所有现代浏览器都支持严格模式。
```

#### 数据类型

```
 ECMAScript有6种简单数据类型（也称为原始类型）： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复 杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集 合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用
```

#### 模板字面量 

```
ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用 单引号或双引号不同，模板字面量保留换行字符，可以跨行定义 字符串
```



#### 字符串插值

```
模板字面量最常用的一个特性是支持字符串插值，也就是可以在 一个连续定义中插入一个或多个值。技术上讲，模板字面量不是 字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得 到的是字符串。模板字面量在定义时立即求值并转换为字符串实 例，任何插入的变量也会从它们最接近的作用域中取值。 字符串插值通过在 ${} 中使用一个JavaScript表达式实现
```

###  Symbol 类型 

```
Symbol （符号）是ECMAScript 6新增的数据类型。符号是原始
值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用
唯一标识符，不会发生属性冲突的危险。
尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属
性的行为才增加的（尤其是因为Object API提供了方法，可以更方便地
发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字
符串形式的对象属性。
```

#### 执行上下文与作用域 

```
执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重 要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们 的行为。每个上下文都有一个关联的变量对象（variable object），而 这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法 通过代码访问变量对象，但后台处理数据会用到它。 全局上下文是最外层的上下文。根据ECMAScript实现的宿主环 境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就 是我们常说的 window 对象（第12章会详细介绍），因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。 使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用 域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销 毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退 出前才会被销毁，比如关闭网页或退出浏览器）。 每个函数调用都有自己的上下文。当代码执行流进入函数时，函 数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会 弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。 上下文中的代码在执行的时候，会创建变量对象的一个作用域链 （scope chain）。这个作用域链决定了各级上下文中的代码在访问变 量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用 域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量： arguments 。（全局上下文中没有这个变量。）作用域链中的下一 个变量对象来自包含上下文，再下一个对象来自再下一个包含上下 文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域 链的最后一个变量对象。 代码执行时的标识符
```

#### 变量声明

ES6之后，JavaScript的变量声明经历了翻天覆地的变化。直到 ECMAScript 5.1， var 都是声明变量的唯一关键字。ES6不仅增加了 let 和 const 两个关键字，而且还让这两个关键字压倒性地超越 var 成为首选。

1. 使用 var 的函数作用域声明
在使用 var 声明变量时，变量会被自动添加到最接近的上下
文。在函数中，最接近的上下文就是函数的局部上下文。在
with 语句中，最接近的上下文也是函数上下文。如果变量未经
声明就被初始化了，那么它就会自动被添加到全局上下文

2. 使用 let 的块级作用域声明
  ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级
  的，这也是JavaScript中的新概念。块级作用域由最近的一对包含
  花括号 {} 界定。换句话说， if 块、 while 块、 function
  块，甚至连单独的块也是 let 声明变量的作用域。

3. let 与 var 的另一个不同之处是在同一作用域内不能声明两 次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError 。

4.  使用 const 的常量声明 除了 let ，ES6同时还增加了 const 关键字。使用 const 声 明的变量必须同时初始化为某个值。一经声明，在其生命周期的 任何时候都不能再重新赋予新值。

  const 声明只应用到顶级原语或者对象。换句话说，赋值为对 象的 const 变量不能再被重新赋值为其他引用值，但对象的键 则不受限制。

#### 垃圾回收

```
 JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码 执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是 个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个 负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很 简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程 是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程 中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且 不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题， 意味着靠算法是解决不了的。 我们以函数中局部变量的正常生命周期为例。函数中的局部变量 会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应 的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局 部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不 再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序 必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回 收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏 览器的发展史上，用到过两种主要的标记策略：标记清理和引用计 数。
```



####  标记清理

```
 JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个 变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑 上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运 行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下 文的标记。 给变量加标记的方式有很多种。比如，当变量进入上下文时，反 转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列 表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不 重要，关键是策略。 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记 住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以 及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标 记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到 它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并 收回它们的内存。 到了2008年，IE、Firefox、Opera、Chrome和Safari都在自己的 JavaScript实现中采用标记清理（或其变体），只是在运行垃圾回收的 频率上有所差异。
```

#### 引用计数

```
 另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给 它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一 个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他 值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办 法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为0的值的内存。 引用计数最早由Netscape Navigator 3.0采用，但很快就遇到了严重 的问题：循环引用。所谓循环引用，就是对象A有一个指针指向对象 B，而对象B也引用了对象A。
```

####  日期格式化方法

```
Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串： toDateString() 显示日期中的周几、月、日、年（格式特定于实 现） toTimeString() 显示日期中的时、分、秒和时区（格式特定于实 现） toLocaleDateString() 显示日期中的周几、月、日、年（格式特 定于实现和地区）
toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实 现）； toUTCString() 显示完整的UTC日期（格式特定于实现）。
```

####  Boolean

```
Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就
使用 Boolean 构造函数并传入 true 或 false 

Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true
或 false 。 toString() 方法被调用时也会被覆盖，返回字符
串 "true" 或 "false" 。不过， Boolean 对象在ECMAScript中用得很
少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用
Boolean 对象时
```

#### Number

```
Number 是对应数值的引用类型。要创建一个 Number 对象，就使
用 Number 构造函数并传入一个数值

与 Boolean 类型一样， Number 类型重写了 valueOf() 、
toLocaleString() 和 toString() 方法。 valueOf() 方法返回
Number 对象表示的原始数值，另外两个方法返回数值字符串。
toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式
的数值字符串

toFixed() 方法返回包含指定小数点位数的数值字符串
```

#### String

```
String 是对应字符串的引用类型。要创建一个 String 对象，使
用 String 构造函数并传入一个数值

String 对象的方法可以在所有字符串原始值上调用。3个继承的方
法 valueOf() 、 toLcaleString() 和 toString() 都返回对象的原
始字符串值

每个 String 对象都有一个 length 属性，表示字符串中字符的数
量。
```

#### 对象解构

```
ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套
数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象
匹配的结构来实现对象属性赋值。、

使用解构，可以在一个类似对象字面量的结构中，声明多个变
量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那
么可以使用简写语法

解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属
性，而如果引用的属性不存在，则该变量的值就是 undefined
```

