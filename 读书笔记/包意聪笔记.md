### 什么是JavaScript

```
     1995年，JavaScript问世,那时候主要是代替Perl等服务端语言处理输入验证,网景公司希望通过在其Navigator浏览器中加入JavaScript来改变这个局面,JavaScript逐渐成为市面上所有主流浏览器的标配。如今，JavaScript的应用也不再局限于据验证，而是渗透到浏览器窗口及其内容的方方面面。JavaScript已被公认为主流的编程语言，能够实现复杂的计算与交互，括闭包、匿名（lambda）函数，甚至元编程等特性。不仅是桌面浏览器，手机浏览器和屏幕阅读器也支持JavaScript，其重要性可见一斑。就连拥有自家客户端脚本语言VBScript的微软公司，也在其Internet Explorer（以下简称IE）浏览器最初的版本中包含了自己的JavaScript实现。
    javascript实现包含以下几个部分:  核心(ECMAScript)  文档对象模型(DOM)  浏览器对象模型(BOM)
    JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。ECMAScript:由ECMA-262定义并提供核心功能。文档对象模型（DOM）：提供与网页内容交互的方法和接口。浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。
    JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、Chrome、Safari和Opera）不同程度的支持。所有浏览器基本上对ES5（ECMAScript 5）提供了完善的支持，而对ES6（ECMAScript 6）和ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Level 3的支持日益趋于规范。HTML5中收录的BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。
```

### <script> 元素

```
将JavaScript插入HTML的主要方法是使用 <script> 元素。这个元素是由网景公司创造出来，并最早在Netscape Navigator 2中实现的。后来，这个元素被正式加入到HTML规范。 <script> 元素有下列8个属性:
     1.async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
     2.charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
     3.crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin="anonymous" 配置文件请求不必设置凭据标志。crossorigin="use-credentials" 设置凭据标志，意味着出站请求会包含凭据。
	4.defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。
	5.integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。
	6.language ：废弃。最初用于表示代码块中的脚本语言（如 "JavaScript" 、 "JavaScript1.2" 或 "VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。
	7.src ：可选。表示包含要执行的代码的外部文件。
	8.type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。按照惯例，这个值始终都是 "text/javascript" ，尽管 "text/javascript" 和 "text/ecmascript" 都已经废弃。
```



```
   JavaScript是通过<script>元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。
   本章的重点可以总结如下。要包含外部JavaScript文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。所有<script>元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在<script>元素中的代码必须严格按次序解释。对不推迟执行的脚本，浏览器必须解释完位于<script>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把<script>元素放到页面末尾，介于主内容之后及</body>标签之前。
   可以使用defer属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本总是按照它们被列出的次序执行。可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
   通过使用<noscript>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则<noscript>元素中的任何内容都不会被渲染。
```

```
	JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。
	下面总结一下ECMAScript中的基本元素。ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number、String和Symbol。与其他语言不同，ECMAScript不区分整数和浮点值，只有Number一种数值数据类型。Object是一种复杂数据类型，它是这门语言中所有对象的基类。严格模式为这门语言中某些容易出错的部分施加了限制。
	ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if语句、for语句和switch语句等。			ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值undefined。
```

### 区分大小写：

```
首先要知道的是，ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量test和变量Test是两个不同的变量。类似地，typeof不能作为函数名，因为它是一个关键字（后面会介绍）。但Typeof是一个完全有效的函数名。
```

### 标识符：

```
  	所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：第一个字符必须是一个字母、下划线（_）或美元符号（$）；剩下的其他字符可以是字母、下划线、美元符号或数字。
注意关键字、保留字、true、false和null不能作为标识符。
```

### 注释：

```
单行注释：块注释以一个斜杠和一个星号（/*）开头，以它们的反向组合（*/）结尾
多行注释：/*这是多行注释*/
```

### 严格模式：

```
	严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行："usestrict"; 
	所有现代浏览器都支持严格模式。
```

### 语句：

```
ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾
	if之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句
	在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。
```

### 变量：

```
	每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var、const和let。其中，var在ECMAScript的所有版本中都可以使用，而const和let只能在ECMAScript 6及更晚的版本中使用。
	
var关键字：
	要定义变量，可以使用var操作符（注意var是一个关键字），后跟变量名（即标识符，如前所述）：varmessage;
	var声明作用域：使用var操作符定义的变量会成为包含它的函数的局部变量。比如，使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁
	在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。
	 var声明提升：使用var时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部
	---------------------------------------------------------------
let声明：
	let跟var的作用差不多，但有着非常重要的区别。最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域。let也不允许同一个块作用域中出现冗余声明。这样会导致报错
对声明冗余报错不会因混用let和var而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。
====================================================
	暂时性死区let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。
====================================================
	全局声明与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。
	let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。
	
	 条件声明在使用var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它。
	 使用try/catch语句或typeof操作符也不能解决，因为条件块中let声明的作用域仅限于该块。
------------------------------------------------------------------	 
	 for循环中的let声明在let出现之前，for循环定义的迭代变量会渗透到循环体外部
------------------------------------------------------------------ 
	 const声明：
	 const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。
	 const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。
	 即使JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，而且const变量跟let变量很相似，也不能用const来声明迭代变量（因为迭代变量会自增）

总结：1. 不使用var有了let和const，大多数开发者会发现自己不再需要var了。限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。2. const优先，let次之使用const声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用const来声明变量，只在提前知道未来会有修改时，再使用let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。
```

### 数据类型：

```
ECMAScript有6种简单数据类型（也称为原始类型）
	Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。
	还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用
```

### typeof操作符：

```
	因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一
	"undefined"表示值未定义；"boolean"表示值为布尔值；"string"表示值为字符串；"number"表示值为数值；"object"表示值为对象（而不是函数）或null；"function"表示值为函数；"symbol"表示值为符号。
	注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。
	函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。
```

### 操作符：

```
	描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。
	一元操作符只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是ECMAScript中最简单的操作符。
	递增/递减操作符递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加1，把两个加号（++）放到变量前头即可
	================================
	一元加和减一元加和减操作符对大多数开发者来说并不陌生，它们在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：如果将一元减应用到非数值，则会执行与使用Number()转型函数一样的类型转换：布尔值false和true转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的valueOf()和/或toString()方法以得到可以转换的值。
```

### if语句：

```
		这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript会自动调用Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为true，则执行语句statement1；如果条件求值为false，则执行语句statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。
```

### do-while语句：

```
do-while语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。
```

### while语句：

```
	while语句是一种先测试：循环语句，即先检测退出条件，再执行循环体内的代码。因此，while循环体内的代码有可能不会执行。
```

### for语句：

```
	for语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式
```

### for-in语句：

```
	for-in语句是一种严格的迭代语句，用于枚举对象中的非符号键属性			ECMAScript中对象的属性是无序的，因此for-in语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。如果for-in循环要迭代的变量是null或undefined，则不执行循环体。
```

### for-of语句：

```
for-of语句是一种严格的迭代语句，用于遍历可迭代对象的元素
for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素。关于可迭代对象
```

### 标签语句：

```
	标签语句用于给语句加标签，语法如下：label:statement下面是一个例子：start:for(leti=0;i<count;i++){console.log(i);}在这个例子中，start是一个标签，可以在后面通过break或continue语句引用。标签语句的典型应用场景是嵌套循环。
```

### break和continue语句：

```
	break和continue语句为执行循环代码提供了更严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而continue语句也用于立即退出循环，但会再次从循环顶部开始执行。
	outermost标签标识的是第一个for语句。正常情况下，每个循环执行10次，意味着num++语句会执行100次，而循环结束时console.log的结果应该是100。但是，break语句带来了一个变数，即要退出到的标签。添加标签不仅让break退出（使用变量j的）内部循环，也会退出（使用变量i）的外部循环。当执行到i和j都等于5时，循环停止执行，此时num的值是55。continue语句也可以使用标签
	
	组合使用标签语句和break、continue能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。
```

### with语句：

```
	ith语句的用途是将代码作用域设置为特定的对象，其语法是：with(expression)statement;使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利
	with语句用于连接location对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location对象，看它是否有一个同名的属性。如果有，则该变量会被求值为location对象的属性。
	
	严格模式不允许使用with语句，否则会抛出错误。
```

### switch语句：

```
	switch语句是与if语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中switch语句跟C语言中switch语句的语法非常相似
	switch(expression){casevalue1:statementbreak;casevalue2:statementbreak;casevalue3:statementbreak;casevalue4:statementbreak;default:statement}
	
	为避免不必要的条件判断，最好给每个条件后面都加上break语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了break
```

### 函数：

```
	函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function关键字声明，后跟一组参数，然后是函数体。
	
	基本语法：functionfunctionName(arg0,arg1,...,argN){statements}
	
	可以通过函数名来调用函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。
	ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值。
	要注意的是，只要碰到return语句，函数就会立即停止执行并退出。因此，return语句后面的代码不会被执行。
	
	严格模式对函数也有一些限制：函数不能以eval或arguments作为名称；函数的参数不能叫eval或arguments；两个函数的参数不能叫同一个名称。如果违反上述规则，则会导致语法错误，代码也不会执行。
```

### 小结：

```
	JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number、String和Symbol。
	与其他语言不同，ECMAScript不区分整数和浮点值，只有Number一种数值数据类型。Object是一种复杂数据类型，它是这门语言中所有对象的基类。严格模式为这门语言中某些容易出错的部分施加了限制。ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if语句、for语句和switch语句等。ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值undefined。
```

## 变量、作用域与内存：

### 原始值与引用值：

```
	变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。
	引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。
	只有引用值可以动态添加后面可以使用的属性。
	原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。
```

### 复制值：

```
	把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来
```

### 传递参数：

```
	ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。
	ECMAScript中函数的参数就是局部变量。
```

### 确定类型：

```
	typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回"object"，
	--------------------------------------------------------------
	typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符
				result=variableinstanceofconstructor
-------------------------------------------------------------------
	typeof操作符在用于检测函数时也会返回"function"。当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回"function"。ECMA-262规定，任何实现内部[[Call]]方法的对象都应该在typeof检测时返回"function"。因为上述浏览器中的正则表达式实现了这个方法，所以typeof对正则表达式也返回"function"。在IE和Firefox中，typeof对正则表达式返回"object"。
```

### 执行上下文与作用域：

```
	执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）
	每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
	上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。
	代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activationobject）用作变量对象。
	函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。
	函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。
```

